#!/usr/bin/wish
package require xBlt 3

#source data_source.tcl
#source comment_source.tcl
#source data_mod.tcl
#source scroll.tcl
#source hielems.tcl
#source readout.tcl
#source format_time.tcl


if {$::argc != 1} {
  error "Usage: sig_view <file>"
}
set file [lindex $::argv 0]

#################################
##### read signal from file

set pars{chan} {}

set ff [open $file]
set cn 0
set t0 0
set dt 1
while {[gets $ff line] >= 0} {

  # * means end of header
  if {$line == "*"} {break}

  # remove comments
  set line [regexp -inline {^[^#]*} $line]
  set line [lindex $line 0]

  # trim spaces
  set line [string trim $line " \t"]

  # skip empty lines
  if {$line == {}} {continue}

  set line [regexp -inline {^([^:]*):\s*(.*)} $line]
  set key [lindex $line 1]
  set val [lindex $line 2]

  if { $key == "dt" } {
    set dt [lindex $val 0]
  }
  if { $key == "t0" } {
    set t0 [lindex $val 0]
  }
  if { $key == "chan" } {
    set chan${cn}_name [lindex $val 0]
    set chan${cn}_sc   [lindex $val 1]
    set chan${cn}_ov   [lindex $val 2]
    blt::vector create chan${cn}
    incr cn
  }
  set pars{$key} $val
}
read $ff 1

if {$cn<0} {error "no data"}

while {1} {
  set data [read $ff [expr 2*$cn]]
  if {$data == {}} {break}
  binary scan $data S${cn} v
  for {set i 0} {$i<$cn} {incr i} {
    set n chan${i}_sc
    chan$i append [expr 1.0*$$n*[lindex $v $i]]
  }
}
set N [chan0 length]

close $ff

blt::vector create t
t seq $t0 [expr $dt*$N] $dt

#################################



blt::graph .p -highlightthickness 0
pack .p -fill both -expand yes -side top

checkbutton .b -text Crosshairs -variable v
pack .b -side top

checkbutton .b2 -text Readout -variable v2 
pack .b2 -side top

entry .m -textvariable mes -relief flat -state readonly \
    -width 50 -font [.b2 cget -font] -highlightthickness 0
pack .m -side top
proc show_message {s args} {set ::mes [string map {\n " "} $s]}

xblt::plotmenu .p -showbutton 1 ;# -menuoncanvas 0

xblt::crosshairs .p -variable v -usemenu 1

xblt::readout .p -variable v2 -active 1 -interpolate yes -onmarkers x* \
    -usemenu 1 -eventcommand {1 show_message}


.p marker create text -name xmark -text "Readout enabled" \
    -coords {4.7 0} -bg green
.p marker create text -name ymark -text "Readout\ndisabled" \
    -coords {7 0.5} -bg red

xblt::hielems .p -usemenu 1
.p legend configure -activebackground white
set m [xblt::legmenu .p -showseparator 1]
$m add command -label Delete -command {
    .p element delete [xblt::legmenu::curelem .p]
}

xblt::measure .p -event <Key-equal> -quickevent <Alt-1> \
    -usemenu 1 \
    -command show_message -commandlabel "Save reading"

xblt::zoomstack .p -scrollbutton 2 -usemenu 1 -axes {x y}
.p axis configure y2 -hide 0

xblt::rubberrect::add .p -type x -modifier Shift \
    -configure {-outline blue} \
    -invtransformx x -command show_rect ;# -cancelbutton ""
proc show_rect {graph x1 x2 y1 y2} {
    show_message "$x1 -- $x2"
}

set m [xblt::plotmenu .p -showseparator 1]
$m add command -label Exit -command exit

#    checkbutton .p.scroll -variable oscroll \
#        -text "Auto scroll"
#    set ::oscroll 0
#    pack .p.scroll -side left -padx 2

bind .p <Enter> {focus %W}

for {set i 0} {$i<$cn} {incr i} {
  .p element create d$i -xdata t -ydata chan$i -symbol {} -color blue
}

#DataMod #auto .p;
#Scroll  #auto .p .s;

xblt::readout::set_axis_format .p x "%.3f rad"
xblt::readout::set_element_format .p d2 "%.4f cm"
