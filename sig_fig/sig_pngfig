#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long qw(GetOptions Configure);

############################################################
# Parse options

sub usage {
  print qq*sig_pngfig -- create fig file for PNG signal spectrogram.

Usage: sig_pngfig [options] <PNG> <FIG>

Options:

-W | --figw  -- Set image width in xfig (cm). Default: 10.

-H | --fight -- Set image height in xfig (cm).
   Use -1 to keep aspect ratio. Default: -1.

-X | --figx  -- Set image shift in xfig (cm). Default: 1.

-Y | --figy  -- Set image shift in xfig (cm). Default: 1.

--ticklen -- Set tick length (cm). Default: 0.1.

--textsp -- Set text spacing (cm). Default: 0.1.

--textpts -- Set text size in points. Default: 10.

--df -- Shift frequency scale. Default: 0.

--dt -- Shift time scale. Default: 0.

--mind <d> -- Keep user objectswith depth >= d from old file. Default: 50

--maxd <d> -- Keep user objects with depth <= d from old file. Default: 50

-h | --help  -- show help message

PNG should be created with `sigfilter sfft_pnm | sig_pngtopnm` programs.
Old fig file will be renamed to \*.bak if it exists.

*;
  exit 1;
}

my $figw = 10;
my $figh = -1;
my $figx = 1;
my $figy = 1;
my $ticklen = 0.1;
my $textsp  = 0.1;
my $textpts  = 10;
my $help = 0;

my $df = 0;
my $dt = 0;

# xfig object depths
my $idepth = 500; # image
my $fdepth = 152; # image frame
my $tdepth = 151; # ticks
my $ldepth = 150; # labels

my $mind = 50;
my $maxd = 50;

GetOptions(
  "W|figw=s"         => \$figw,
  "H|figh=s"         => \$figh,
  "X|figx=s"         => \$figx,
  "Y|figy=s"         => \$figy,
  "ticklen=s"        => \$ticklen,
  "textsp=s"         => \$textsp,
  "textpts=s"        => \$textpts,
  "df=s"             => \$df,
  "dt=s"             => \$dt,
  "mind=i"           => \$mind,
  "maxd=i"           => \$maxd,
  "h|help"           => \$help,
) or usage();
usage() if $help;

usage() if scalar(@ARGV) != 2;
my $png = $ARGV[0];
my $fig = $ARGV[1];


############################################################
# Get info from png file

my %pars;
open IN, "sig_pnginfo $png |" or die "can't run sig_pnginfo\n";
foreach (<IN>){
  if (/^cmax:\s+(.*)/) {$pars{cmax} = $1; next;}
  if (/^cmin:\s+(.*)/) {$pars{cmin} = $1; next;}
  if (/^fmax:\s+(.*)/) {$pars{fmax} = $1; next;}
  if (/^fmin:\s+(.*)/) {$pars{fmin} = $1; next;}
  if (/^tmax:\s+(.*)/) {$pars{tmax} = $1; next;}
  if (/^tmin:\s+(.*)/) {$pars{tmin} = $1; next;}
  if (/^window:\s+(.*)/)   {$pars{win} = $1; next;}
  if (/^width:\s+(.*)/)    {$pars{W} = $1; next;}
  if (/^height:\s+(.*)/)   {$pars{H} = $1; next;}
  if (/^sc_width:\s+(.*)/) {$pars{S} = $1; next;}
  if (/^logscale:\s+(.*)/) {$pars{log} = $1; next;}
  if (/^colors:\s+(.*)/)   {$pars{col} = $1; next;}
  print "unknown setting: $_\n";
}
close IN;

$pars{fmin} -= $df;
$pars{fmax} -= $df;
$pars{tmin} -= $dt;
$pars{tmax} -= $dt;

print STDERR "$pars{fmin} $pars{fmax} $df\n";

############################################################
# Calculate image dimensions in FIG file
# $pars{S} - width of colorbar, it is not included int $figw!

  my $cm2fig = 1200.0 / 1.05 / 2.54;
  my $X1 = $figx*$cm2fig;
  my $Y1 = $figy*$cm2fig;

  $figh = $figw * 1.0*$pars{H}/$pars{W} if $figh<=0;
  my $figs = $figw * 1.0*$pars{S}/$pars{W}; # width of colorbar

  my $X2 = int($X1 + $figw*$cm2fig);
  my $X3 = int($X2 + $figs*$cm2fig);
  my $Y2 = int($Y1 + $figh*$cm2fig);
  $X1 = int($X1);
  $Y1 = int($Y1);

  my $tl = int($ticklen*$cm2fig);  # tick length

  my $texth = int($textpts/72*2.54 *$cm2fig); #text height
  $textsp = int($textsp*$cm2fig); #text spacing, convert to fig units

############################################################
# Get information from old fig file, rename it to *.bak

  my @old_objs;
  if ( -f $fig ) {
    # extract old objects
    open IN, "sig_figdat --mind $mind --maxd $maxd $fig |"
      or die "can't run sig_figref: $!";
    foreach (<IN>) {
      my @a = split /\s+/;
      next if scalar @a < 7;
      my $comm = '';
      my (@x,@y);
      for (my $i=3; $i<=$#a; $i++){
        if ($a[$i] eq '#') {
          $comm = $a[$i+1] if $i<$#a;
          last;
        }
        push @x, $a[$i]-$dt if $i%2==1;
        push @y, $a[$i]-$df if $i%2==0;
      }
      push @old_objs, {
        type  => $a[0],
        color => $a[1],
        depth => $a[2],
        x     => [@x],
        y     => [@y],
        comm  => $comm,
      };
    }
    close IN;
    rename $fig, "$fig.bak";
  }


  open FIG, "> $fig" or die "Can't open fig file: $!\n";

  # header
  print FIG "#FIG 3.2\n",
            "Portrait\nCenter\nMetric\nA4\n100.00\nSingle\n-2\n";
  print FIG "1200 2\n";

  # image frame
  print FIG "2 2 0 1 0 7 $fdepth -1 -1 0.000 0 0 -1 0 0 5\n",
            "\t$X1 $Y1  $X2 $Y1  $X2 $Y2  $X1 $Y2 $X1 $Y1\n";
  print FIG "2 2 0 1 0 7 $fdepth -1 -1 0.000 0 0 -1 0 0 5\n",
            "\t$X2 $Y1  $X3 $Y1  $X3 $Y2  $X2 $Y2 $X2 $Y1\n";
  print FIG "2 5 0 1 0 -1 $idepth -1 -1 0.000 0 0 -1 0 0 5\n",
            "\t0 $png\n",
            "\t$X1 $Y1  $X3 $Y1  $X3 $Y2  $X1 $Y2 $X1 $Y1\n";

############################################################
# Create ticks and labels
  sub vlist{
    my $v1 = shift;
    my $v2 = shift;
    $v1 != $v2 or return $v1;

    my $dv = $v2-$v1;
    my $exp = 1;
    $exp*=10 while abs($dv*$exp) < 1;
    $exp/=10 while abs($dv*$exp) >= 10;

    my $step = int($dv*$exp)/10/$exp;
    my $vv1 = int($v1/$step)*$step;
    my $vv2 = int($v2/$step)*$step;

    my @ret;
    for (my $v=$vv1; $v<=$vv2; $v+=$step) {
      push @ret, $v if $v>=$v1 && $v<=$v2;
    }
    return @ret;
  }

  sub mk_vticks{
    my $x    = shift;
    my $y1   = shift;
    my $y2   = shift;
    my $v1   = shift;
    my $v2   = shift;
    my $flip = shift ? -1:+1;
    my @vv = vlist($v1,$v2);
    foreach my $v (@vv){
      my $yl = int($y1 + ($v-$v1)/($v2-$v1)*($y2-$y1));
      my $yt = int($yl + $texth/2);
      my $xl = $x + $flip*$tl; # tick end
      my $xt = $x - $flip*$textsp; # text position
      my $al = $flip>0 ? 2:0;
      print FIG "2 1 0 1 0 7 $tdepth -1 -1 0.000 0 0 -1 0 0 2\n\t$x $yl $xl $yl\n",
                "4 $al 0 $ldepth -1 18 10 0.0000 4 135 375 $xt $yt $v\\001\n";
    }
  }

  sub mk_hticks{
    my $y    = shift;
    my $x1   = shift;
    my $x2   = shift;
    my $v1   = shift;
    my $v2   = shift;
    my $flip = shift ? -1:+1;
    my @vv = vlist($v1,$v2);
    foreach my $v (@vv){
      my $x = int($x1 + ($v-$v1)/($v2-$v1)*($x2-$x1));
      my $yl = $y - $flip*$tl; # tick end
      my $yt = $y + int(($flip>0)? $texth+$textsp : -$textsp); # text position
      print FIG "2 1 0 1 0 7 $tdepth -1 -1 0.000 0 0 -1 0 0 2\n\t$x $y $x $yl\n",
                "4 1 0 $ldepth -1 18 $textpts 0.0000 4 135 375 $x $yt $v\\001\n";
    }
  }

  mk_vticks($X1, $Y2, $Y1, $pars{fmin}, $pars{fmax}, 0);
  mk_vticks($X3, $Y2, $Y1, $pars{cmin}, $pars{cmax}, 1);
  mk_hticks($Y2, $X1, $X2, $pars{tmin}, $pars{tmax}, 0);
  mk_hticks($Y1, $X1, $X2, $pars{tmin}, $pars{tmax}, 1);

  my $kx = ($X2-$X1)/($pars{tmax}-$pars{tmin});
  my $x0 = $X1 - $pars{tmin}*$kx;

  my $ky = ($Y1-$Y2)/($pars{fmax}-$pars{fmin});
  my $y0 = $Y2 - $pars{fmin}*$ky;

############################################################
## add old user data

  foreach my $o (@old_objs){

    # convert coordinates
    $_ = int($_*$kx + $x0) foreach (@{$o->{x}});
    $_ = int($_*$ky + $y0) foreach (@{$o->{y}});

    if ($o->{type} eq 'BOX'){
      my $x1 = ${$o->{x}}[0];
      my $x2 = ${$o->{x}}[1];
      my $y1 = ${$o->{y}}[0];
      my $y2 = ${$o->{y}}[1];

      print FIG "# $o->{comm}\n" if $o->{comm};
      print FIG "2 2 0 1 $o->{color} 7 $o->{depth} -1 -1 0.000 0 0 -1 0 0 5\n";
      print FIG "	$x1 $y1 $x2 $y1 $x2 $y2 $x1 $y2 $x1 $y1\n";

      next;
    }

    if ($o->{type} eq 'POINT' || $o->{type} eq 'LINE'){
      my $n = scalar @{$o->{x}};
      print FIG "# $o->{comm}\n" if $o->{comm};
      print FIG "2 1 0 1 $o->{color} 7 $o->{depth} -1 -1 0.000 0 0 -1 0 0 $n\n";
      for (my $i=0; $i < $n; $i++){
        my $x = ${$o->{x}}[$i];
        my $y = ${$o->{y}}[$i];
        print FIG "	$x $y\n";
      }
      next;
    }

  }


############################################################
   close FIG;
