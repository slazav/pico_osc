#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long qw(GetOptions Configure);


############################################################
# Extract data form FIG file written by sig_pngfig.


############################################################
# Parse options

sub usage {
  print qq*sig_figdat -- extract data form FIG file written by sig_pngfig.

Usage: sig_figdat [options] <FIG>

Options:
  --mind <d> -- Extract only objects with depth >= d. Default: 50
  --maxd <d> -- Extract only objects with depth <= d. Default: 50
  -h | --help  -- show help message


Program prints extracted objects in the following format:
  <type> <fig color> <fig depth> <coordinates, time-freq> # <comment>

Example of the program output:

  LINE 2 50 26.4372106014047 44746.7410666667 35.8460868634767 44892.1616 # comment1
  POINT 2 50 43.6242836506804 44454.5658666667 # 
  BOX 0 50 12.3527577919227 22.0935422656936 43914.2418666667 44994.8898666667 # comment2

*;
  exit 1;
}

my $mind = 50;
my $maxd = 50;
my $help = 0;

GetOptions(
  "mind=i"           => \$mind,
  "maxd=i"           => \$maxd,
  "h|help"           => \$help,
) or usage();
usage() if $help;

usage() if scalar(@ARGV) != 1;
my $fig = $ARGV[0];


############################################################

  my @x2fig = [0,1];
  my @y2fig = [0,1];

  my $state='init';
  my $color=0;
  my $depth=0;
  my $comm="";
  my $comm1="";
  my $type="";
  my @crd = ();
  my @objects = ();

  open FIG, $fig or die "can't open $fig\n";

  foreach my $l (<FIG>){

    # switch to a scanning state:
    $state='scan' if $l=~/^1200 2/;

    # Extract object comments:
    if ($state ne 'init' && $l=~/^#\s+(\S+)/) {
      $comm=$1; next;
    }

    # Start reading an object
    if ($state ne 'init' && $l=~/^\d/){

      # save old object if needed
      push @objects, {color=>$color, depth=>$depth, comm=>$comm1, crd=>[@crd], type=>$type}
        if $#crd>=0 && $type;
      @crd=();
      $comm1 = $comm;
      $comm = "";
      $type = "";
      $color = 0;
      $depth = 0;

      # image
      if ($l=~/^2 5/){
        $state = 'img';
        $type = 'image';
        next;
      }

      # box
      if ($l=~/^2 2 0 1 (\d+) \d+ (\d+)/){
        next if $2 < $mind || $2 > $maxd;
        $state = 'crd';
        $type = 'box';
        $color = $1;
        $depth = $2;
        next;
      }

      # lines/points
      if ($l=~/^2 1 0 1 (\d+) \d+ (\d+) .* (\d+)$/){
        next if $2 < $mind || $2 > $maxd;
        $state = 'crd';
        $type = $3==1? 'point':'line';
        $color = $1;
        $depth = $2;
        next;
      }

      next;
    }

    # image, second line
    if ($state eq 'img' && $l=~/\s+\d+\s+(.*\.png)$/){
      $state = 'crd';
      $comm1 = $1; # use comm field for filename!
      next;
    }

    # extract object coordinates:
    if ($state eq 'crd' && $l=~/^\s+\d+/) {
      $l=~s/^\s*(.*?)\s*$/$1/;
      push(@crd, split /\s+/, $l);
      next;
    }

    $state='scan' if $state ne 'init';
  }


  # save old object
  push @objects, {color=>$color, depth=>$depth, comm=>$comm1, crd=>[@crd], type=>$type}
    if $#crd>=0 && $type;
  close FIG;

############################################################
# find image object

  my $img;
  foreach (@objects) {$img=$_ if $_->{type} eq 'image'; }

  die "can't extract image coordinates for $fig" if !$img || scalar(@{$img->{crd}}) != 10;
  my @c = @{$img->{crd}};
  # get xmin, xmax, ymin, ymax
  my ($xmin, $xmax, $ymin, $ymax) = ($c[0],$c[0],$c[1],$c[1]);
  for (my $i = 0; $i<9; $i+=2) {
    $xmin = $c[$i] if $xmin > $c[$i];
    $xmax = $c[$i] if $xmax < $c[$i];
    $ymin = $c[$i+1] if $ymin > $c[$i+1];
    $ymax = $c[$i+1] if $ymax < $c[$i+1];
  }

  # add fig file path to png file:
  my $path = $fig; $path =~ s/[^\/]*$//;
  my $file = $path . $img->{comm};

#####################################################
## read PNG, extract PNG parameters:

  open IN, "sig_pnginfo $file |" or die "can't run sig_pnginfo\n";
  my ($fmin,$fmax,$tmin,$tmax);
  my ($W,$H,$S);
  foreach (<IN>){
    if (/^fmax:\s+(.*)/) {$fmax = $1; next;}
    if (/^fmin:\s+(.*)/) {$fmin = $1; next;}
    if (/^tmax:\s+(.*)/) {$tmax = $1; next;}
    if (/^tmin:\s+(.*)/) {$tmin = $1; next;}
    if (/^width:\s+(.*)/)    {$W = $1; next;}
    if (/^height:\s+(.*)/)   {$H = $1; next;}
    if (/^sc_width:\s+(.*)/) {$S = $1; next;}
  }
  close IN;

  my $df = $fmax-$fmin;
  my $dt = $tmax-$tmin;
  my $dy = $ymax-$ymin;
  my $dx = $xmax-$xmin;

  # exclude sidebar size
  $dx = $dx*$W/($W+$S);
  $xmax = $xmin + $dx;

  # conversion coeffitients time->x, freq->y
  my $X0 = $xmin - $dx/$dt*$tmin; my $KX = $dx/$dt;
  my $Y0 = $ymin + $dy/$df*$fmax; my $KY = -$dy/$df;

#  printf "CNVX $X0 $KX\n";
#  printf "CNVY $Y0 $KY\n";

  # print data
  foreach my $o (@objects) {

    # convert coordinates, find min and max
    my @crd = @{$o->{crd}};
    my ($xmin, $xmax, $ymin, $ymax);
    for (my $i=0; $i<= $#crd-1; $i+=2 ) {
      $crd[$i]   = ($crd[$i]-$X0)/$KX;
      $crd[$i+1] = ($crd[$i+1]-$Y0)/$KY;
      $xmin=$crd[$i]   if !defined($xmin) || $xmin>$crd[$i];
      $xmax=$crd[$i]   if !defined($xmax) || $xmax<$crd[$i];
      $ymin=$crd[$i+1] if !defined($ymin) || $ymin>$crd[$i+1];
      $ymax=$crd[$i+1] if !defined($ymax) || $ymax<$crd[$i+1];
    }

    if ($o->{type} eq 'box') {
      print "BOX $o->{color} $o->{depth} $xmin $ymin $xmax $ymax # $o->{comm}\n";
      next;
    }

    if ($o->{type} eq 'point' && scalar(@crd) == 2) {
      print "POINT $o->{color} $o->{depth} $crd[0] $crd[1] # $o->{comm}\n";
      next;
    }

    if ($o->{type} eq 'line' && scalar(@crd) > 0) {
      print "LINE $o->{color} $o->{depth} ", join(' ', @crd), " # $o->{comm}\n";
      next;
    }
  }
